<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bezier Curve</title>
    <style>
        html, body {
            width:  100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        #canvas {
            display: block;
        }

        .wrapper {
            position: relative;
        }

        .wrapper > canvas, #inputs {
            position: absolute;
            left: 0;
            top: 0;
        }

        #inputs {
            width: 100%;
        }

        #Tlabel {
            position: absolute;
            left: 29%;
            top: 15px;

            opacity: 0.7;
            color: #969696;
            font-family: Calibri, 'Trebuchet MS', sans-serif;
        }

        .slider {
            position: absolute;
            left: 30%;
            top: 20px;
            width: 40%;
            height: 6px;

            -webkit-appearance: none;
            appearance: none;
            border-radius: 3px;
            background: #484848;
            outline: none;
            opacity: 0.7;
            -webkit-transition: 0.2s;
            transition: opacity 0.2s;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 5px;
            height: 20px;
            border-radius: 50%;
            background: #969696;
        }

        .slider::-moz-range-thumb {
            width: 3px;
            height: 20px;
            border-radius: 50%;
            background: #969696;
        }

        .sliderTextValue {
            position: absolute;
            left: 71%;
            top: 15px;
            width: 5ch;

            opacity: 0.7;
            border: 0;
            color: #969696;
            font-family: Calibri, 'Trebuchet MS', sans-serif;
        }

        .sliderTextValue:hover {
            opacity: 1;
        }

        .sliderTextValue::-webkit-outer-spin-button,
        .sliderTextValue::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .sliderTextValue {
            -moz-appearance: textfield;
        }

    </style>
</head>
<body>
    <div class="wrapper">
        <canvas id="canvas" width="1280" height="720"></canvas>
        <div id="inputs">
            <label for="Tslider" id="Tlabel">t</label>

            <input id="Tslider" 
                   class="slider" 
                   autocomplete="off" 
                   type="range" 
                   value="1" 
                   min="0" 
                   max="1" 
                   step="0.005" 
                   oninput="sliderUpdateT(this.value)"/>

            <input id="TsliderTextValue" 
                   class="sliderTextValue" 
                   autocomplete="off" 
                   type="number" 
                   value="1" 
                   min="0" 
                   max="1" 
                   step="0.01"
                   oninput="sliderUpdateT(this.value)"/>
        </div>
    </div>

    <script>

        var canvas = document.getElementById(`canvas`);
        var ctx = canvas.getContext(`2d`);
        ctx.canvas.width  = window.innerWidth;
        ctx.canvas.height = window.innerHeight;
        var canvasWidth = canvas.width;
        var canvasHeight = canvas.height;
        var canvasData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);

        const BACKGROUNDCOLOR = `rgb(40, 40, 40)`;
        const CONSTRUCTIONLINECOLOR = `rgb(0, 0, 0)`;

        ctx.fillStyle = BACKGROUNDCOLOR;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        const CIRCLESIZE = 7;

        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
        }

        let p1, p2, p3, p4, selectedPoint, previousPoint;
        const outboundsPoint = new Point(0, 0);
        let T = 1;
        
        function sliderUpdateT(value){
            T = value;
            let slider = document.getElementById("Tslider");
            let sliderText = document.getElementById("TsliderTextValue");

            slider.value = T;
            sliderText.value = T;
            redraw();
        }

        let oldWidth = canvasWidth, oldHeight = canvasHeight;

        window.addEventListener('resize', resizeCanvas, false);

        let moved = false;

        let downListener = () => {
            let eventx, eventy;
            moved = true;
            if (event.type == "touchstart") {
                eventx = event.touches[0].clientX;
                eventy = event.touches[0].clientY;
            } else {
                eventx = event.clientX;
                eventy = event.clientY;
            }
            choosePoint(eventx, eventy);
        }
        document.addEventListener('mousedown', downListener);
        document.addEventListener('touchstart', downListener);

        let moveListener = () => {
            if (moved) {
                movePoint(event);
            }
        }
        document.addEventListener('mousemove', moveListener);
        document.addEventListener('touchmove', moveListener);
        
        let upListener = () => {
             moved = false;
             selectedPoint = outboundsPoint;
        }
        document.addEventListener('mouseup', upListener);
        document.addEventListener('mouseend', upListener);

        function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }

        function choosePoint(x, y) {
            let pDist = [];
            pDist[0] = calculateDistance(x, y, p1.x, p1.y);
            pDist[1] = calculateDistance(x, y, p2.x, p2.y);
            pDist[2] = calculateDistance(x, y, p3.x, p3.y);
            pDist[3] = calculateDistance(x, y, p4.x, p4.y);

            const min = Math.min(...pDist);
            const index = pDist.indexOf(min);

            if (min < CIRCLESIZE * 1.25) {
                switch (index) {
                    case 0:
                        selectedPoint = p1;
                        break;
                        
                    case 1:
                        selectedPoint = p2;
                        break;
                        
                    case 2:
                        selectedPoint = p3;
                        break;
                        
                    case 3:
                        selectedPoint = p4;
                        break;
                }
            }
        }

        function movePoint(event) {
            var bounds = event.target.getBoundingClientRect();
            
            let eventx, eventy;

            if (event.type == "touchstart" || event.type == "touchmove" || event.type == "touchend") {
                eventx = event.touches[0].clientX;
                eventy = event.touches[0].clientY;
            } else {
                eventx = event.clientX;
                eventy = event.clientY;
            }

            selectedPoint.x = eventx - bounds.left - scrollX;
            selectedPoint.y = eventy - bounds.top - scrollY;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            redraw();
        }

        function resizeCanvas() {
            ctx.canvas.width  = window.innerWidth;
            ctx.canvas.height = window.innerHeight;
            canvasWidth = canvas.width;
            canvasHeight = canvas.height;
            redraw();
        }

        function drawPixel (point, stroke = `black`, width = 1) {
            // ctx.fillRect(point.x, point.y, 1, 1);
            drawLine(previousPoint, point, stroke, width);
            previousPoint = point;
        }

        function drawLine(start, end, stroke = `black`, width = 1) {
            if (stroke) {
                ctx.strokeStyle = stroke;
            }

            if (width) {
                ctx.lineWidth = width;
            }

            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
        }

        function getRandomNumber(min, max) {
            return Math.random() * (max - min) + min;
        }

        function interpolatePoint(first, second, u) {
            return new Point((second.x - first.x) * u + first.x, (second.y - first.y) * u + first.y);
        }

        function init() {
            p1 = new Point(getRandomNumber(100, canvas.width / 2), getRandomNumber(canvas.height / 2, canvas.height - 100));
            p2 = new Point(getRandomNumber(100, canvas.width / 2), getRandomNumber(100, canvas.height / 2));
            p3 = new Point(getRandomNumber(canvas.width / 2, canvas.width - 100), getRandomNumber(100, canvas.height / 2));
            p4 = new Point(getRandomNumber(canvas.width / 2, canvas.width - 100), getRandomNumber(canvas.height / 2, canvas.height - 100));

            for (item of document.getElementsByClassName("sliderTextValue")) {
                item.style.background = BACKGROUNDCOLOR;
            }

            selectedPoint = outboundsPoint;
        }

        function drawPoint(u, stroke = `black`, width = 1) {
            
            let p12 = interpolatePoint(p1, p2, u);
            let p23 = interpolatePoint(p2, p3, u);
            let p34 = interpolatePoint(p3, p4, u);

            let p123 = interpolatePoint(p12, p23, u);
            let p234 = interpolatePoint(p23, p34, u);

            let p1234 = interpolatePoint(p123, p234, u);

            if (equalTo(u, T)) {
                drawLine(p12, p23, CONSTRUCTIONLINECOLOR, 2);
                drawLine(p23, p34, CONSTRUCTIONLINECOLOR, 2);
                drawLine(p123, p234, CONSTRUCTIONLINECOLOR, 2);

            }
            drawPixel(p1234, stroke, width);
        }

        function drawCurve(steps = 200, t = 1, stroke = `black`, width = 1) {
            drawLine(p1, p2, stroke, 2);
            drawLine(p2, p3, stroke, 2);
            drawLine(p3, p4, stroke, 2);

            previousPoint = p1;

            var t0 = 0;
            var u = 1 / steps;
            while (t0 <= t) {
                drawPoint(t0, stroke, 3);
                t0 += u;
            }

            while (t0 <= 1) {
                drawPoint(t0, `rgb(150, 150, 150)`, 1);
                t0 += u;
            }
        }
        
        function scalePoint(point) {
            point.x = point.x * canvasWidth / oldWidth;
            point.y = point.y * canvasHeight / oldHeight;
        }

        function redraw() {
            scalePoint(p1);
            scalePoint(p2);
            scalePoint(p3);
            scalePoint(p4);

            ctx.fillStyle = BACKGROUNDCOLOR;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            drawCurve(200, T);

            drawCircles(p1);
            drawCircles(p2);
            drawCircles(p3);
            drawCircles(p4);

            oldWidth = canvasWidth;
            oldHeight = canvasHeight;
        }

        function drawCircles(point) {
            ctx.fillStyle = `black`;
            ctx.beginPath();
            ctx.arc(point.x, point.y, CIRCLESIZE, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = `gray`;
            ctx.beginPath();
            ctx.arc(point.x, point.y, CIRCLESIZE * 0.85, 0, 2 * Math.PI);
            ctx.fill();
        }

        function equalTo(first, second) {
            return (Math.abs(first - second) < 0.0001)
        }

        init();
        drawCurve(200, T);
        
        drawCircles(p1);
        drawCircles(p2);
        drawCircles(p3);
        drawCircles(p4);
    </script>
</body>
</html>